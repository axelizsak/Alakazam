/**
 * Starknet RPC version 0.2.0
 *
 * StarkNet Node API 0.45.0 - rpc 0.2.1
 * StarkNet Node Write API 0.3.0 - rpc 0.2.1
 * StarkNet Trace API 0.4.0 - rpc 0.2.1
 *
 * TypeScript Representation of OpenRpc protocol types
 */
export declare type FELT = string;
export declare type ADDRESS = FELT;
declare type NUM_AS_HEX = string;
declare type SIGNATURE = Array<FELT>;
declare type BLOCK_NUMBER = number;
declare type BLOCK_HASH = FELT;
declare type TXN_HASH = FELT;
declare type TXN_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';
declare type TXN_TYPE = 'DECLARE' | 'DEPLOY' | 'DEPLOY_ACCOUNT' | 'INVOKE' | 'L1_HANDLER';
declare type BLOCK_STATUS = 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';
declare enum BLOCK_TAG {
    'latest' = 0,
    'pending' = 1
}
declare type BLOCK_ID = {
    block_hash: BLOCK_HASH;
} | {
    block_number: BLOCK_NUMBER;
} | BLOCK_TAG;
declare type MSG_TO_L1 = {
    to_address: FELT;
    payload: Array<FELT>;
};
declare type EVENT = {
    from_address: FELT;
    keys: Array<FELT>;
    data: Array<FELT>;
};
declare type COMMON_RECEIPT_PROPERTIES = {
    transaction_hash: TXN_HASH;
    actual_fee: FELT;
    status: TXN_STATUS;
    block_hash?: BLOCK_HASH;
    block_number?: BLOCK_NUMBER;
    type: TXN_TYPE;
    messages_sent: Array<MSG_TO_L1>;
    events: Array<EVENT>;
};
declare type PENDING_COMMON_RECEIPT_PROPERTIES = {
    transaction_hash: TXN_HASH;
    actual_fee: FELT;
    type?: TXN_TYPE;
    messages_sent: Array<MSG_TO_L1>;
    events: Array<EVENT>;
};
declare type INVOKE_TXN_RECEIPT = COMMON_RECEIPT_PROPERTIES;
declare type DECLARE_TXN_RECEIPT = COMMON_RECEIPT_PROPERTIES;
declare type DEPLOY_TXN_RECEIPT = {
    contract_address: FELT;
} & COMMON_RECEIPT_PROPERTIES;
declare type L1_HANDLER_TXN_RECEIPT = COMMON_RECEIPT_PROPERTIES;
declare type PENDING_DEPLOY_TXN_RECEIPT = {
    contract_address: FELT;
} & PENDING_COMMON_RECEIPT_PROPERTIES;
declare type PENDING_TXN_RECEIPT = PENDING_DEPLOY_TXN_RECEIPT | PENDING_COMMON_RECEIPT_PROPERTIES;
declare type TXN_RECEIPT = INVOKE_TXN_RECEIPT | L1_HANDLER_TXN_RECEIPT | DECLARE_TXN_RECEIPT | DEPLOY_TXN_RECEIPT | DEPLOY_ACCOUNT_TXN_RECEIPT | PENDING_TXN_RECEIPT;
declare type BLOCK_HEADER = {
    block_hash: BLOCK_HASH;
    parent_hash: BLOCK_HASH;
    block_number: BLOCK_NUMBER;
    new_root: FELT;
    timestamp: number;
    sequencer_address: FELT;
};
declare type BLOCK_BODY_WITH_TX_HASHES = {
    transactions: Array<TXN_HASH>;
};
declare type BLOCK_WITH_TX_HASHES = {
    status: BLOCK_STATUS;
} & BLOCK_HEADER & BLOCK_BODY_WITH_TX_HASHES;
declare type PENDING_BLOCK_WITH_TX_HASHES = BLOCK_BODY_WITH_TX_HASHES & {
    timestamp: number;
    sequencer_address: FELT;
    parent_hash: BLOCK_HASH;
};
declare type COMMON_TXN_PROPERTIES = {
    transaction_hash?: TXN_HASH;
} & BROADCASTED_TXN_COMMON_PROPERTIES;
declare type FUNCTION_CALL = {
    contract_address?: ADDRESS;
    entry_point_selector?: FELT;
    calldata?: Array<FELT>;
};
declare type INVOKE_TXN = COMMON_TXN_PROPERTIES & (INVOKE_TXN_V0 | INVOKE_TXN_V1);
declare type DECLARE_TXN = COMMON_TXN_PROPERTIES & {
    class_hash: FELT;
    sender_address: ADDRESS;
};
declare type DEPLOY_TXN = {
    transaction_hash: TXN_HASH;
    class_hash: FELT;
} & DEPLOY_TXN_PROPERTIES;
declare type DEPLOY_ACCOUNT_TXN = COMMON_TXN_PROPERTIES & DEPLOY_ACCOUNT_TXN_PROPERTIES;
declare type DEPLOY_ACCOUNT_TXN_PROPERTIES = {
    contract_address_salt: FELT;
    constructor_calldata: Array<FELT>;
    class_hash: FELT;
};
declare type DEPLOY_ACCOUNT_TXN_RECEIPT = DEPLOY_TXN_RECEIPT;
declare type TXN = INVOKE_TXN | L1_HANDLER_TXN | DECLARE_TXN | DEPLOY_TXN | DEPLOY_ACCOUNT_TXN;
declare enum L1_HANDLER {
    'L1_HANDLER' = 0
}
declare type L1_HANDLER_TXN = {
    transaction_hash: TXN_HASH;
    version: NUM_AS_HEX;
    type: L1_HANDLER;
    nonce: NUM_AS_HEX;
} & FUNCTION_CALL;
declare type BROADCASTED_DEPLOY_ACCOUNT_TXN = BROADCASTED_TXN_COMMON_PROPERTIES & DEPLOY_ACCOUNT_TXN_PROPERTIES;
declare type BROADCASTED_TXN = BROADCASTED_INVOKE_TXN | BROADCASTED_DECLARE_TXN | BROADCASTED_DEPLOY_TXN | BROADCASTED_DEPLOY_ACCOUNT_TXN;
declare type BROADCASTED_INVOKE_TXN = BROADCASTED_TXN_COMMON_PROPERTIES & (INVOKE_TXN_V0 | INVOKE_TXN_V1);
declare type BROADCASTED_TXN_COMMON_PROPERTIES = {
    type: TXN_TYPE;
    max_fee: FELT;
    version: NUM_AS_HEX;
    signature: SIGNATURE;
    nonce: FELT;
};
declare type BROADCASTED_DECLARE_TXN = {
    contract_class: CONTRACT_CLASS;
    sender_address: ADDRESS;
} & BROADCASTED_TXN_COMMON_PROPERTIES;
declare type BROADCASTED_DEPLOY_TXN = {
    contract_class: CONTRACT_CLASS;
} & DEPLOY_TXN_PROPERTIES;
declare type DEPLOY_TXN_PROPERTIES = {
    version: NUM_AS_HEX;
    type: TXN_TYPE;
    contract_address_salt: FELT;
    constructor_calldata: Array<FELT>;
};
declare type INVOKE_TXN_V0 = FUNCTION_CALL;
declare type INVOKE_TXN_V1 = {
    sender_address: ADDRESS;
    calldata: Array<FELT>;
};
declare type BLOCK_BODY_WITH_TXS = {
    transactions: Array<TXN>;
};
declare type BLOCK_WITH_TXS = {
    status: BLOCK_STATUS;
} & BLOCK_HEADER & BLOCK_BODY_WITH_TXS;
declare type PENDING_BLOCK_WITH_TXS = BLOCK_BODY_WITH_TXS & {
    timestamp: number;
    sequencer_address: FELT;
    parent_hash: BLOCK_HASH;
};
declare type CONTRACT_CLASS = {
    program: string;
    entry_points_by_type: {
        CONSTRUCTOR: CONTRACT_ENTRY_POINT_LIST;
        EXTERNAL: CONTRACT_ENTRY_POINT_LIST;
        L1_HANDLER: CONTRACT_ENTRY_POINT_LIST;
    };
    abi?: CONTRACT_ABI;
};
declare type CONTRACT_ABI = Array<CONTRACT_ABI_ENTRY>;
declare type CONTRACT_ABI_ENTRY = FUNCTION_ABI_ENTRY | EVENT_ABI_ENTRY | STRUCT_ABI_ENTRY;
declare enum STRUCT_ABI_TYPE {
    'struct' = 0
}
declare enum EVENT_ABI_TYPE {
    'event' = 0
}
declare enum FUNCTION_ABI_TYPE {
    'function' = 0,
    'l1_handler' = 1,
    'constructor' = 2
}
declare type STRUCT_ABI_ENTRY = STRUCT_ABI_TYPE & {
    name: string;
    size: number;
    members: Array<STRUCT_MEMBER>;
};
declare type STRUCT_MEMBER = {
    offset: number;
} & TYPED_PARAMETER;
declare type EVENT_ABI_ENTRY = {
    name: string;
    keys: Array<TYPED_PARAMETER>;
    data: Array<TYPED_PARAMETER>;
} & EVENT_ABI_TYPE;
declare type FUNCTION_ABI_ENTRY = {
    type: FUNCTION_ABI_TYPE;
    name: string;
    inputs: Array<TYPED_PARAMETER>;
    outputs: Array<TYPED_PARAMETER>;
};
declare type TYPED_PARAMETER = {
    name: string;
    type: string;
};
declare type CONTRACT_ENTRY_POINT_LIST = Array<CONTRACT_ENTRY_POINT>;
declare type CONTRACT_ENTRY_POINT = {
    offset: NUM_AS_HEX;
    selector: FELT;
};
declare type CONTRACT_STORAGE_DIFF_ITEM = {
    address: FELT;
    storage_entries: [key: FELT, value: FELT];
};
declare type DEPLOYED_CONTRACT_ITEM = {
    address: FELT;
    class_hash: FELT;
};
declare type STATE_UPDATE = {
    block_hash: BLOCK_HASH;
    new_root: FELT;
    old_root: FELT;
    state_diff: {
        storage_diffs: Array<CONTRACT_STORAGE_DIFF_ITEM>;
        declared_contract_hashes: Array<FELT>;
        deployed_contracts: Array<DEPLOYED_CONTRACT_ITEM>;
        nonces: Array<{
            contract_address: ADDRESS;
            nonce: FELT;
        }>;
    };
};
declare type STORAGE_KEY = string;
declare type EVENT_FILTER = {
    from_block?: BLOCK_ID;
    to_block?: BLOCK_ID;
    address?: ADDRESS;
    keys?: Array<FELT>;
};
declare type RESULT_PAGE_REQUEST = {
    continuation_token?: string;
    chunk_size: number;
};
declare type EMITTED_EVENT = EVENT & {
    block_hash: BLOCK_HASH;
    block_number: BLOCK_NUMBER;
    transaction_hash: TXN_HASH;
};
declare type SYNC_STATUS = {
    starting_block_hash: BLOCK_HASH;
    starting_block_num: NUM_AS_HEX;
    current_block_hash: BLOCK_HASH;
    current_block_num: NUM_AS_HEX;
    highest_block_hash: BLOCK_HASH;
    highest_block_num: NUM_AS_HEX;
};
declare type FEE_ESTIMATE = {
    gas_consumed: NUM_AS_HEX;
    gas_price: NUM_AS_HEX;
    overall_fee: NUM_AS_HEX;
};
declare enum CALL_TYPE {
    'DELEGATE' = 0,
    'CALL' = 1
}
declare enum ENTRY_POINT_TYPE {
    'EXTERNAL' = 0,
    'L1_HANDLER' = 1,
    'CONSTRUCTOR' = 2
}
declare type FUNCTION_INVOCATION = FUNCTION_CALL & {
    caller_address: FELT;
    code_address: FELT;
    entry_point_type: ENTRY_POINT_TYPE;
    call_type: CALL_TYPE;
    result: FELT;
    calls: NESTED_CALL;
    events: Array<EVENT>;
    messages: MSG_TO_L1;
};
declare type NESTED_CALL = FUNCTION_INVOCATION;
declare type TRACE_ROOT = {
    nonce: FELT;
    signature: FELT;
    function_invocation: FUNCTION_INVOCATION;
};
export declare namespace OPENRPC {
    type Nonce = FELT;
    type BlockWithTxHashes = BLOCK_WITH_TX_HASHES | PENDING_BLOCK_WITH_TX_HASHES;
    type BlockWithTxs = BLOCK_WITH_TXS | PENDING_BLOCK_WITH_TXS;
    type StateUpdate = STATE_UPDATE;
    type Storage = FELT;
    type Transaction = TXN;
    type TransactionReceipt = TXN_RECEIPT;
    type ContractClass = CONTRACT_CLASS;
    type CallResponse = Array<FELT>;
    type EstimatedFee = FEE_ESTIMATE;
    type BlockNumber = BLOCK_NUMBER;
    type BlockHashAndNumber = {
        block_hash: BLOCK_HASH;
        block_number: BLOCK_NUMBER;
    };
    type CHAIN_ID = string;
    type PendingTransactions = Array<TXN>;
    type SyncingStatus = false | SYNC_STATUS;
    type Events = {
        events: Array<EMITTED_EVENT>;
        continuation_token: string;
    };
    type Trace = TRACE_ROOT;
    type Traces = Array<{
        transaction_hash: FELT;
        trace_root: TRACE_ROOT;
    }>;
    type TransactionHash = TXN_HASH;
    type BlockHash = BLOCK_HASH;
    type EventFilter = EVENT_FILTER & RESULT_PAGE_REQUEST;
    type InvokedTransaction = {
        transaction_hash: TXN_HASH;
    };
    type DeclaredTransaction = {
        transaction_hash: TXN_HASH;
        class_hash: FELT;
    };
    type DeployedTransaction = {
        transaction_hash: TXN_HASH;
        contract_address: FELT;
    };
    type Methods = {
        starknet_getBlockWithTxHashes: {
            params: {
                block_id: BLOCK_ID;
            };
            result: BlockWithTxHashes;
            errors: Errors.BLOCK_NOT_FOUND;
        };
        starknet_getBlockWithTxs: {
            params: {
                block_id: BLOCK_ID;
            };
            result: BlockWithTxs;
            errors: Errors.BLOCK_NOT_FOUND;
        };
        starknet_getStateUpdate: {
            params: {
                block_id: BLOCK_ID;
            };
            result: StateUpdate;
            errors: Errors.BLOCK_NOT_FOUND;
        };
        starknet_getStorageAt: {
            params: {
                contract_address: ADDRESS;
                key: STORAGE_KEY;
                block_id: BLOCK_ID;
            };
            result: Storage;
            errors: Errors.CONTRACT_NOT_FOUND | Errors.BLOCK_NOT_FOUND;
        };
        starknet_getTransactionByHash: {
            params: {
                transaction_hash: TXN_HASH;
            };
            result: Transaction;
            errors: Errors.TXN_HASH_NOT_FOUND;
        };
        starknet_getTransactionByBlockIdAndIndex: {
            params: {
                block_id: BLOCK_ID;
                index: number;
            };
            result: Transaction;
            errors: Errors.BLOCK_NOT_FOUND | Errors.INVALID_TXN_INDEX;
        };
        starknet_getTransactionReceipt: {
            params: {
                transaction_hash: TXN_HASH;
            };
            result: TransactionReceipt;
            errors: Errors.TXN_HASH_NOT_FOUND;
        };
        starknet_getClass: {
            params: {
                block_id: BLOCK_ID;
                class_hash: FELT;
            };
            result: ContractClass;
            errors: Errors.BLOCK_NOT_FOUND | Errors.CLASS_HASH_NOT_FOUND;
        };
        starknet_getClassHashAt: {
            params: {
                block_id: BLOCK_ID;
                contract_address: ADDRESS;
            };
            result: FELT;
            errors: Errors.BLOCK_NOT_FOUND | Errors.CONTRACT_NOT_FOUND;
        };
        starknet_getClassAt: {
            params: {
                block_id: BLOCK_ID;
                contract_address: ADDRESS;
            };
            result: ContractClass;
            errors: Errors.BLOCK_NOT_FOUND | Errors.CONTRACT_NOT_FOUND;
        };
        starknet_getBlockTransactionCount: {
            params: {
                block_id: BLOCK_ID;
            };
            result: number;
            errors: Errors.BLOCK_NOT_FOUND;
        };
        starknet_call: {
            params: {
                request: FUNCTION_CALL;
                block_id: BLOCK_ID;
            };
            result: Array<FELT>;
            errors: Errors.CONTRACT_NOT_FOUND | Errors.INVALID_MESSAGE_SELECTOR | Errors.INVALID_CALL_DATA | Errors.CONTRACT_ERROR | Errors.BLOCK_NOT_FOUND;
        };
        starknet_estimateFee: {
            params: {
                request: BROADCASTED_TXN;
                block_id: BLOCK_ID;
            };
            result: FEE_ESTIMATE;
            errors: Errors.CONTRACT_NOT_FOUND | Errors.INVALID_MESSAGE_SELECTOR | Errors.INVALID_CALL_DATA | Errors.CONTRACT_ERROR | Errors.BLOCK_NOT_FOUND;
        };
        starknet_blockNumber: {
            params: {};
            result: BLOCK_NUMBER;
            errors: Errors.NO_BLOCKS;
        };
        starknet_blockHashAndNumber: {
            params: {};
            result: BLOCK_HASH & BLOCK_NUMBER;
            errors: Errors.NO_BLOCKS;
        };
        starknet_chainId: {
            params: {};
            result: CHAIN_ID;
        };
        starknet_pendingTransactions: {
            params: {};
            result: PendingTransactions;
        };
        starknet_syncing: {
            params: {};
            result: SyncingStatus;
        };
        starknet_getEvents: {
            params: {
                filter: EVENT_FILTER & RESULT_PAGE_REQUEST;
            };
            result: Events;
            errors: Errors.PAGE_SIZE_TOO_BIG | Errors.INVALID_CONTINUATION_TOKEN | Errors.BLOCK_NOT_FOUND;
        };
        starknet_getNonce: {
            params: {
                block_id: BLOCK_ID;
                contract_address: ADDRESS;
            };
            result: FELT;
            errors: Errors.BLOCK_NOT_FOUND | Errors.CONTRACT_NOT_FOUND;
        };
        starknet_addInvokeTransaction: {
            params: {
                invoke_transaction: BROADCASTED_INVOKE_TXN;
            };
            result: InvokedTransaction;
        };
        starknet_addDeclareTransaction: {
            params: {
                declare_transaction: BROADCASTED_DECLARE_TXN;
            };
            result: DeclaredTransaction;
            errors: Errors.INVALID_CONTRACT_CLASS;
        };
        starknet_addDeployTransaction: {
            params: {
                deploy_transaction: BROADCASTED_DEPLOY_TXN;
            };
            result: DeployedTransaction;
            errors: Errors.INVALID_CONTRACT_CLASS;
        };
        starknet_addDeployAccountTransaction: {
            params: BROADCASTED_DEPLOY_ACCOUNT_TXN;
            result: {
                transaction_hash: TXN_HASH;
                contract_address: FELT;
            };
            errors: Errors.CLASS_HASH_NOT_FOUND;
        };
        starknet_traceTransaction: {
            params: {
                transaction_hash: TXN_HASH;
            };
            result: Trace;
            errors: Errors.TXN_HASH_NOT_FOUND | Errors.NO_TRACE_AVAILABLE | Errors.INVALID_BLOCK_HASH | Errors.TXN_HASH_NOT_FOUND;
        };
        starknet_traceBlockTransactions: {
            params: {
                block_hash: BLOCK_HASH;
            };
            result: Traces;
            errors: Errors.INVALID_BLOCK_HASH;
        };
    };
}
export declare namespace Errors {
    interface FAILED_TO_RECEIVE_TXN {
        code: 1;
        message: 'Failed to write transaction';
    }
    interface CONTRACT_NOT_FOUND {
        code: 20;
        message: 'Contract not found';
    }
    interface INVALID_MESSAGE_SELECTOR {
        code: 21;
        message: 'Invalid message selector';
    }
    interface INVALID_CALL_DATA {
        code: 22;
        message: 'Invalid call data';
    }
    interface BLOCK_NOT_FOUND {
        code: 24;
        message: 'Block not found';
    }
    interface INVALID_TXN_INDEX {
        code: 27;
        message: 'Invalid transaction index in a block';
    }
    interface CLASS_HASH_NOT_FOUND {
        code: 28;
        message: 'Class hash not found';
    }
    interface PAGE_SIZE_TOO_BIG {
        code: 31;
        message: 'Requested page size is too big';
    }
    interface NO_BLOCKS {
        code: 32;
        message: 'There are no blocks';
    }
    interface INVALID_CONTINUATION_TOKEN {
        code: 33;
        message: 'The supplied continuation token is invalid or unknown';
    }
    interface CONTRACT_ERROR {
        code: 40;
        message: 'Contract error';
    }
    interface INVALID_CONTRACT_CLASS {
        code: 50;
        message: 'Invalid contract class';
    }
    interface NO_TRACE_AVAILABLE {
        code: 10;
        message: 'No trace available for transaction';
        data: {
            status: 'RECEIVED' | 'REJECTED';
        };
    }
    interface INVALID_BLOCK_HASH {
        code: 24;
        message: 'Invalid block hash';
    }
    interface TXN_HASH_NOT_FOUND {
        code: 25;
        message: 'Transaction hash not found';
    }
}
export {};
