"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const starknet_1 = require("starknet");
const __1 = require("..");
const encoding_1 = require("../utils/encoding");
const fossilL1HeadersStoreAddress = '0x6ca3d25e901ce1fff2a7dd4079a24ff63ca6bbf8ba956efc71c1467975ab78f';
const fossilFactRegistryAddress = '0x363108ac1521a47b4f7d82f8ba868199bc1535216bbedfc1b071ae93cc406fd';
const proposalRegistryStore = 'Voting_proposal_registry_store';
const strategyParamsStore = 'Voting_voting_strategy_params_store';
const timestampToEthBlockNumberStore = 'Timestamp_timestamp_to_eth_block_number';
const latestL1BlockStore = '_latest_l1_block';
const snapshotTimestampOffset = 3;
async function fetchStrategyParams(index, envelope) {
    const lengthAddress = (0, encoding_1.getStorageVarAddress)(strategyParamsStore, index.toString(16), '0x0');
    const length = parseInt((await starknet_1.defaultProvider.getStorageAt(envelope.data.message.space, lengthAddress)), 16);
    return Promise.all([...Array(length)].map(async (_, i) => {
        const lengthAddress = (0, encoding_1.getStorageVarAddress)(strategyParamsStore, index.toString(16), (i + 1).toString(16));
        return starknet_1.defaultProvider.getStorageAt(envelope.data.message.space, lengthAddress);
    }));
}
async function getBlockStorage(call, address, envelope) {
    if (call === 'vote') {
        const proposalAddress = (0, encoding_1.getStorageVarAddress)(proposalRegistryStore, envelope.data.message.proposal.toString(16));
        const timestamp = (await starknet_1.defaultProvider.getStorageAt(envelope.data.message.space, (0, encoding_1.offsetStorageVar)(proposalAddress, snapshotTimestampOffset)));
        return [address, (0, encoding_1.getStorageVarAddress)(timestampToEthBlockNumberStore, timestamp)];
    }
    return [fossilL1HeadersStoreAddress, (0, encoding_1.getStorageVarAddress)(latestL1BlockStore)];
}
async function fetchBlock(call, address, envelope) {
    const [contractAddress, key] = await getBlockStorage(call, address, envelope);
    const block = parseInt((await starknet_1.defaultProvider.getStorageAt(contractAddress, key)), 16);
    // 1 block offset due to
    // https://github.com/snapshot-labs/sx-core/blob/e994394a7109de5527786cb99e981e132122fad4/contracts/starknet/VotingStrategies/SingleSlotProof.cairo#L60
    return block - 1;
}
async function fetchProofInputs(call, address, index, envelope, clientConfig) {
    const [block, strategyParams] = await Promise.all([
        fetchBlock(call, address, envelope),
        fetchStrategyParams(index, envelope)
    ]);
    const response = await fetch(clientConfig.ethUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'eth_getProof',
            params: [
                strategyParams[0],
                [__1.utils.encoding.getSlotKey(envelope.address, strategyParams[1])],
                `0x${block.toString(16)}`
            ]
        })
    });
    const data = await response.json();
    if (data.error)
        throw new Error('Failed to fetch proofs');
    return __1.utils.storageProofs.getProofInputs(block, data.result);
}
const singleSlotProofStrategy = {
    type: 'singleSlotProof',
    async getParams(call, address, index, envelope, clientConfig) {
        const proofInputs = await fetchProofInputs(call, address, index, envelope, clientConfig);
        return proofInputs.storageProofs[0];
    },
    async getExtraProposeCalls(address, index, envelope, clientConfig) {
        const proofInputs = await fetchProofInputs('propose', address, index, envelope, clientConfig);
        return [
            {
                contractAddress: fossilFactRegistryAddress,
                entrypoint: 'prove_account',
                calldata: [
                    proofInputs.accountOptions,
                    proofInputs.blockNumber,
                    proofInputs.ethAddress.values[0],
                    proofInputs.ethAddress.values[1],
                    proofInputs.ethAddress.values[2],
                    proofInputs.accountProofSizesBytes.length,
                    ...proofInputs.accountProofSizesBytes,
                    proofInputs.accountProofSizesWords.length,
                    ...proofInputs.accountProofSizesWords,
                    proofInputs.accountProof.length,
                    ...proofInputs.accountProof
                ]
            }
        ];
    }
};
exports.default = singleSlotProofStrategy;
